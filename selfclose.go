package svg

import (
	"bytes"
)

// SelfCloseEmptyElements replaces closing tags of
// empty elements from a marshaled document,
// inserting '/' at the end of opening tags.
// (It does not actually check whether the elements are empty,
// as this would require more complex pattern matching.
// The elements in question, if generated by this package, are
// always empty, though.)
// The conversion is done in place; the original byte slice,
// with adjusted length, is returned, containing the converted
// document.
func SelfCloseEmptyElements(buf []byte) []byte {
	ir := 0
	iw := 0
L:
	for {
		tail := buf[ir:]
		ntail := len(tail)
		if ntail <= 0 {
			copy(buf[iw:], tail)
			iw += ntail
			break
		}
		i := bytes.Index(tail, []byte{'>', '<', '/'})
		if i == -1 {
			copy(buf[iw:], tail)
			iw += ntail
			break
		}
		closingTag := tail[i+3:]
		if end := bytes.IndexByte(closingTag, '>'); end >= 3 {
			closingTag = closingTag[:end]
			for _, tag := range selfClosingTags {
				switch bytes.Compare(tag, closingTag) {
				case -1:
					continue
				case 0:
					// Closing tag matches; now test whether the
					// previous '>' is part of a </title> tag;
					// in this case self-closing is not possible
					if i >= 6 && bytes.Equal(tail[i-6:i], []byte("/title")) {
						continue
					}
					copy(buf[iw:], tail[:i])
					n := len(tail[:i])
					ir += n + 3 + len(tag)
					iw += n
					buf[iw] = ' '
					iw++
					buf[iw] = '/'
					iw++
					continue L
				}
				break
			}
		}
		n := len(tail[:i]) + 3
		copy(buf[iw:], tail[:i+3])
		iw += n
		ir += n
	}

	return buf[:iw]
}

var selfClosingTags = [][]byte{
	[]byte("circle"),
	[]byte("ellipse"),
	[]byte("line"),
	[]byte("polygon"),
	[]byte("polyline"),
	[]byte("rect"),
	[]byte("use"),
}
